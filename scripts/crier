#!/usr/bin/env python

from __future__ import print_function
from argparse import RawTextHelpFormatter
from flask import Flask, request
from flask_restful import Resource, Api
import argparse
import json
import signal
import sys

from crier.script import Script, SCHEMA
from crier.orchestrator import Orchestrator


def parse_arguments():
    description = """
A simple webserver that reports everything it hears.

jsonschema for --scripts option:
""" + SCHEMA
    parser = argparse.ArgumentParser(description=description,
            formatter_class=RawTextHelpFormatter)
    parser.add_argument('--timeout', type=int)
    parser.add_argument('--scripts', type=str,
            default='[{"status_code": 200, "repeat": -1}]',
            help='A JSON formatted list of scripts. See jsonschema above. (default: %(default)s)')

    arguments = parser.parse_args()

    return arguments


# This isn't great, but it's the best we can do with Flask:
# http://stackoverflow.com/questions/2838244/get-open-tcp-port-in-python
# http://stackoverflow.com/questions/5085656/how-to-get-the-current-port-number-in-flask
def get_open_port():
    import socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('localhost', 0))
    port = s.getsockname()[1]
    s.close()
    return port


orchestrator = Orchestrator()
app = Flask(__name__)

class TheOnlyResource(Resource):
    def post(self):
        request_info = {
            'url': request.url,
            'headers': dict(request.headers),
            'data': request.get_json(),
            'args': dict(request.args),
        }
        print(' - ' + json.dumps(request_info))

        rv = orchestrator.next_response()
        if orchestrator.is_done:
            shutdown_server()

        return rv


def shutdown_server():
    func = request.environ.get('werkzeug.server.shutdown')
    if func is None:
        raise RuntimeError('Not running with the Werkzeug Server')
    func()


if __name__ == '__main__':
    api = Api(app)
    api.add_resource(TheOnlyResource, '/')

    arguments = parse_arguments()

    scripts = Script.from_string(arguments.scripts)
    orchestrator.set_scripts(scripts)

    if arguments.timeout is not None:
        signal.alarm(arguments.timeout)
    port = get_open_port()

    print(port, file=sys.stderr)
    app.run(port=port)
