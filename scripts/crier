#!/usr/bin/env python

from __future__ import print_function
from argparse import RawTextHelpFormatter
from flask import Flask, request
from flask_restful import Resource, Api
import argparse
import json
import signal
import sys

from crier.validator import load_and_validate, SCHEMA


class Orchestrator:
    def __init__(self):
        self.scripts = []
        self.active_script_idx = 0

    def set_scripts(self, scripts_data):
        for script_data in scripts_data:
            self.scripts.append(Script(**script_data))
        self.active_script_idx = 0

    @property
    def active_script(self):
        return self.scripts[self.active_script_idx]

    def next_response(self):
        if not self.is_done:
            result = self.active_script.next_response()
            if self.active_script.is_done:
                self.active_script_idx += 1
            return result
        else:
            raise RuntimeError("No more scripts")

    @property
    def is_done(self):
        return self.active_script_idx >= len(self.scripts)

class Script:
    def __init__(self, status_code, headers=None, response=None, repeat=0):
        self.status_code = status_code
        self.headers = headers if headers is not None else {}
        self.response = response if response is not None else {}
        self.repeat = repeat
        self.count = 0

    def next_response(self):
        if not self.is_done:
            self.count += 1
            return self.response, self.status_code, self.headers
        else:
            raise RuntimeError("Script repeated too many times")

    @property
    def is_done(self):
        if self.repeat == -1:
            return False
        else:
            return self.count > self.repeat


def parse_arguments():
    description = """
A simple webserver that reports everything it hears.

jsonschema for --scripts option:
""" + SCHEMA
    parser = argparse.ArgumentParser(description=description,
            formatter_class=RawTextHelpFormatter)
    parser.add_argument('--timeout', type=int)
    parser.add_argument('--scripts', type=str,
            default='[{"status_code": 200, "repeat": -1}]',
            help='A JSON formatted list of scripts. See jsonschema above. (default: %(default)s)')

    arguments = parser.parse_args()

    return arguments


# This isn't great, but it's the best we can do with Flask:
# http://stackoverflow.com/questions/2838244/get-open-tcp-port-in-python
# http://stackoverflow.com/questions/5085656/how-to-get-the-current-port-number-in-flask
def get_open_port():
    import socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('localhost', 0))
    port = s.getsockname()[1]
    s.close()
    return port


orchestrator = Orchestrator()
app = Flask(__name__)

class TheOnlyResource(Resource):
    def post(self):
        request_info = {
            'url': request.url,
            'headers': dict(request.headers),
            'data': request.get_json(),
            'args': dict(request.args),
        }
        print(' - ' + json.dumps(request_info))

        rv = orchestrator.next_response()
        if orchestrator.is_done:
            shutdown_server()

        return rv


def shutdown_server():
    func = request.environ.get('werkzeug.server.shutdown')
    if func is None:
        raise RuntimeError('Not running with the Werkzeug Server')
    func()


if __name__ == '__main__':
    api = Api(app)
    api.add_resource(TheOnlyResource, '/')

    arguments = parse_arguments()

    scripts_data = load_and_validate(arguments.scripts)
    orchestrator.set_scripts(scripts_data)

    if arguments.timeout is not None:
        signal.alarm(arguments.timeout)
    port = get_open_port()

    print(port, file=sys.stderr)
    app.run(port=port)
