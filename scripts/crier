#!/usr/bin/env python

from __future__ import print_function
from argparse import RawTextHelpFormatter
from flask import Flask, request
import argparse
import json
import signal
import sys

from crier.validator import load_and_validate, SCHEMA


class Orchestrator:
    def __init__(self):
        self.scripts = []
        self.count = 0

    def set_scripts(self, scripts):
        self.scripts = scripts
        self.count = 0

    def next_response(self):
        if not self.is_done:
            self.count += 1
            return self.response_tuple(self.scripts[self.count - 1])
        else:
            raise RuntimeError("No more scripts")

    @staticmethod
    def response_tuple(script):
        body = script.get('response', '')
        status_code = script['status_code']
        headers = script.get('headers', {})
        return body, status_code, headers

    @property
    def is_done(self):
        return len(self.scripts) <= self.count


def parse_arguments():
    description = """
A simple webserver that reports everything it hears.

jsonschema for --scripts option:
""" + SCHEMA
    parser = argparse.ArgumentParser(description=description,
            formatter_class=RawTextHelpFormatter)
    parser.add_argument('--timeout', type=int, default=10)
    parser.add_argument('--scripts', type=str, help='A JSON formatted list of scripts. See jsonschema above.')

    arguments = parser.parse_args()

    return arguments


# This isn't great, but it's the best we can do with Flask:
# http://stackoverflow.com/questions/2838244/get-open-tcp-port-in-python
# http://stackoverflow.com/questions/5085656/how-to-get-the-current-port-number-in-flask
def get_open_port():
    import socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('localhost', 0))
    port = s.getsockname()[1]
    s.close()
    return port


orchestrator = Orchestrator()
app = Flask(__name__)


@app.route('/', methods=['POST'])
def log_request():
    request_info = {
        'url': request.url,
        'headers': dict(request.headers),
        'data': request.get_json(),
        'args': dict(request.args),
    }
    print(' - ' + json.dumps(request_info))

    rv = orchestrator.next_response()
    if orchestrator.is_done:
        shutdown_server()

    return rv


def shutdown_server():
    func = request.environ.get('werkzeug.server.shutdown')
    if func is None:
        raise RuntimeError('Not running with the Werkzeug Server')
    func()


if __name__ == '__main__':
    arguments = parse_arguments()

    scripts = load_and_validate(arguments.scripts)
    orchestrator.set_scripts(scripts)

    signal.alarm(arguments.timeout)
    port = get_open_port()

    print(port, file=sys.stderr)
    app.run(port=port)
